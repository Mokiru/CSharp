# 贪心

## 引入

贪心算法（greedy algorithm），是用计算机来模拟一个$\lfloor$贪心$\rfloor$的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

## 解释

### 适用范围

贪心算法在有最优子结构的问题中尤为有效，最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

### 证明

贪心算法有两种证明方法：反证法和归纳法，一般情况下，一道题只会用到其中的一种方法来证明。

1. 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。
2. 归纳法：先算得出边界情况（例如$n=1$）的最优解$F_1$，然后再证明：对于每个$n$，$F_{n+1}$都可以由$F_n$推导出结果。

## 要点

### 常见题型

在提高组难度以下的题目中，最常见的贪心有两种。
- $\lfloor$ 我们将XXX按照某某排序，然后按某种顺序（例如从小到大）选择 $\rfloor$。
- $\lfloor$ 我们每次都取XXX中最大/小的东西，并更新XXX。 $\rfloor$（有时XXX中最大/小的东西可以优化，比如用优先队列维护）。

二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

### 排序解法

用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

### 后悔解法

思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。

## 区别

### 与动态规划的区别

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 例题

### 后悔法的例题

> 约翰的工作日从$0$时刻开始，有$10^9$个单位时间，在任一单位时间，他都可以选择编号$1$到$N$的$N(1\leq N\leq 10^5)$项工作中的任意一项工作来完成。工作$i$的截止时间是$D_i(1\leq D_i\leq 10^9)$，完成后获利是$P_i(1\leq P_i\leq 10^9)$。在给定的工作利润和截止时间下，求约翰能够获得的利润最大为多少。

> 1.先假设每一项工作都做，将各项工作按截止时间排序后入队；2.在判断第$i$项工作做与不做时，若其截止时间符合条件，则将其与队中报酬最小的元素比较，若第$i$项工作报酬较高（后悔），则`ans+=a[i].p-q.top()`。用优先队列（小根堆）来维护队首元素最小。3.当$a[i].d\leq q.size()$可以这么理解从$0$开始到$a[i].d$这个时间段只能做$a[i].d$个任务，而若$q.size()\geq a[i].d$说明完成`q.size()`个任务时间大于等于`a[i].d`的时间，所以第$i$个任务获利比较大的时候应该把最小的任务从优先级队列中换出。
```c#


```
