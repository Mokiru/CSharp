# B树

## 引入

在计算机科学中，B树（B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。

在B树中，有两种节点：
1. 内部节点（internal node）：存储了数据以及指向其子节点的指针。
2. 叶子节点（leaf node）：与内部节点不同的是，叶子节点只存储数据，并没有子节点。

树是一种数据结构，树用多个节点储存元素。某些节点存在一定的关系，用连线表示。二叉树是一种特殊的树，每个节点最多有两个子树。二叉树常用于实现二叉搜索树和二叉堆。而AVL树是特殊的二叉树，是最早被发明的自平衡二叉查找树，B树保留了自平衡的特点，但B树二点每个节点可以拥有两个以上的子节点，因此B树是一种多路搜索树。

## 性质

首先介绍以下一棵$m$阶的B树的特性，$m$表示这个树的每一个节点最多可以拥有的子节点个数。一棵$m$阶的B树满足的性质如下：
1. 每个节点最多有$m$个子节点。
2. 每一个非叶子节点（除根节点）最少有$m/2$上取整个子节点。
3. 如果根节点不是叶子节点，那么它至少有两个子节点。
4. 有$k$个子节点的非叶子节点拥有$k-1$个键，且升序排列，满足$k[i]< k[i+1]$。
5. 每个节点最多包含$2k-1$个键。
6. 所有的叶子节点都在同一层。

一个简单的图例如下：
![alt text](image.png)

## 过程

与二叉搜索树类似，B树的基本操作有查找，遍历，插入，删除。

### 查找

B树中的节点包含有多个键。假设需要查找的是$k$，那么从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定，因为是从根节点开始的二分法查找，所以查找一个键的代码如下：
```c++
BTreeNode* BTreeNode::search(int k) {
    //找到第一个大于等于待查找键 k 的键
    int i = 0;
    while (i < n && k > keys[i]) i++;

    //如果找到的第一个键等于 k，返回节点指针
    if (keys[i] == k) return this;

    //如果没有找到键 k 且当前节点为叶子节点则返回NULL
    if (leaf == true) return NULL;

    //递归
    return C[i]->search(k);
}
```

### 遍历

B树的中序遍历与二叉搜索树的中序遍历也很相似，从最左边的孩子节点开始，递归地打印最左边地孩子节点，然后对剩余的孩子和键重复相同的过程。最后，递归打印最右边的孩子节点。

遍历的代码如下：
```c++
void BTreeNode::traverse() {
    //有n个键和n+1个孩子
    //遍历n个键和前n个孩子
    int i;
    for (int i = 0; i < n; i++) {
        //如果当前节点不是叶子节点，在打印key[i]之前
        //先遍历以C[i]为根的子树
        if (leaf == false) C[i]->traverse();
        cout << " " << keys[i];
    }

    //打印以最后一个孩子为根的子树
    if (leaf == false) C[i]->traverse();
}
```

### 插入

为了方便表述，插入设定为在以$o$为根节点的B树中插入一个值为$v$的新节点。

一个新插入的$v$总是被插入到叶子节点。与二叉搜索树的插入操作类似，从根节点开始，向下遍历直接到叶子节点，将值为$v$的新节点插入到相应的叶子节点。与二叉搜索树不同的是，通过最小度定义了一个节点可以包含键的个数的一个取值范围，所以在插入一个新节点时，就需要确认插入这个叶子节点之后，它的父节点是否超出该节点本身最大可容纳的节点个数。

针对一棵高度为$h$的$m$阶B树，插入一个元素时，首先要验证该元素在B树中是否存在，如果不存在，那么就要在叶子节点中插入该新的元素，此时分3种情况：
1. 如果叶子节点空间足够，即该节点的关键字数小于$m-1$，则直接插入在叶子节点的左边或右边；
2. 如果空间满了以至于没有足够的空间去添加新的元素，即该节点的关键字数已经有了$m$个，则需要将该节点进行【分裂】，将一半数量的关键字元素分裂到新的其相邻右节点中，中间关键字元素上移到父节点中，而且当节点中关键元素向右移动了，相关的指针也需要右移。1.从该节点的原有元素和新的元素中选择出中位数；2.小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值；3.分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推，如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。

如果一直分裂到根节点，那么就需要创建一个新的根节点。它有一个分隔值和两个子节点。

这就是根节点并不像内部节点一样有最少子节点数量限制的原因。每个节点中元素的最大数量是$U-1$。当一个节点分裂时，一个元素被移动到它的父节点，但是一个新的元素增加了进来。所以最大的元素数量$U-1$必须能够被分成两个合法的节点。如果$U-1$是奇数，那么$U=2L$，总共有$2L-1$个元素，一个新的节点有$L-1$个元素，另外一个有$L$个元素，都是合法的节点，如果$U-1$是偶数，那么$U=2L-1$，总共有$2L-2$个元素，一半是$L-1$，正好是节点允许的最小元素数量。

```c++
void BTree::insert(int k) {
    //如果树为空树
    if (root == NULL) {
        //为根节点分配空间
        root = new BTreeNode(t, true);
        root->keys[0] = k; //插入节点k
        root->n = 1; //更新根节点的关键字的个数为1
    } else {
        //当根节点已满，则对B-树进行上溢操作
        if (root->n == 2 * t - 1) {
            //为新的根节点分配空间
            BTreeNode* s = new BTreeNode(t, false);

            //将旧的根节点作为新的根节点的孩子
            s->C[0] = root;
        }
    }
}
```