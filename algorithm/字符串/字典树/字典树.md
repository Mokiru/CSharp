# 字典树(Trie)

## 定义

字典树，英文名为trie，顾名思义，就是一个像字典一样的树。

## 引入

![alt text](image.png)

可以发现，这棵字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子，$1\rightarrow 4\rightarrow 8\rightarrow 12$表示的就是字符串$caa$。

trie的结构，我们用$\delta (u,c)$表示结点$u$的$c$字符指向的下一个结点，或者说是结点$u$代表的字符串后面添加一个字符$c$形成的字符串的结点。（$c$的取值范围和字符集大小有关，不一定是$0~26$。）

有时需要标记插入进trie的是哪些字符串，每次插入完成时在这个字符串所代表的节点出打上标记即可。

## 实现

结构体封装：


```c++
struct trie {
    int nex[100000][26], cnt;
    bool exist[100000];//该结点结尾的字符串是否存在

    void insert(char *s, int l) {//插入字符串
        int p = 0;
        for (int i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!nex[p][c]) {
                nex[p][c] = ++cnt; //如果没有就添加这个结点
            }
            p = nex[p][c];
        }
        exist[p] = 1;
    }

    bool find(char *s, int l) {//查找字符串
        int p = 0;
        for (int i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!nex[p][c]) return 0;
            p = nex[p][c];
        }
        return exist[p];
    }
};
```

## 应用

### 检索字符串

字典树最基础的应用——查找一个字符串是否在$\lceil$ 字典 $\rfloor$中出现过。

[于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 500010;
int n, m;
string s;
int nex[N][27], cnt = 1;
int exist[N];

int main() {
	cin >> n;	
	for (int i = 0; i < n; i++) {
		cin >> s;
		int p = 1;
		for (int j = 0; j < s.size(); j++) {
			int c = s[j] - 'a';
			if (!nex[p][c]) {
				nex[p][c] = ++cnt;
			
			}
			p = nex[p][c];
		}
		exist[p] = 1;
	}
	cin >> m;
	for (int i = 0; i < m; i++) {
		cin >> s;
		int p = 1;
		for (int j = 0; j < s.size(); j++) {
			int c = s[j] - 'a';
			p = nex[p][c];
			if (!p) break;
		}
		if (exist[p] == 1) {
			cout << "OK" << endl;
			exist[p] = 2;
		} else if (exist[p] == 2) {
			cout << "REPEAT" << endl;
		} else {
			cout << "WRONG" << endl;
		}
	}
	return 0;
}
```

### AC自动机

trie是AC自动机的一部分

### 维护异或极值

将数的二进制表示看做一个字符串，就可以建出字符集为${0,1}$的$trie$树。

[最长异或路径](https://www.luogu.com.cn/problem/P4551)

思路：首先选择一个节点作为根节点（默认1），使用$dis[i]$表示节点$i$到根节点(1)的异或和，我们知道$(u,v)$的异或和值就等于$dis[u]^dis[v]$，将每一个$dis[i]$插入到$trie$中，就可以快速找到每个$dis[u]$对应和它异或和最大的$dis[v]$：从$trie$的根开始，如果能向$dis[u]$当前二进制位不同的子树走，就向那边走，并记录答案，否则没有选择。从高位开始向低位存储，因为尽量满足高位为$1$。

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;

int cnt = 0, nxt[N << 1], head[N << 1], to[N << 1], weight[N << 1];

int child[N << 5][2], dis[N], tot = 1;

int ans = 0;

void add(int u, int v, int w) {
	nxt[++cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
	weight[cnt] = w;
}

void insert(int value) {
	// 从高位到低位
	int p = 1;
	for (int i = 30; i >= 0; i--) {
		int c = (value >> i) & 1;
		if (!child[p][c]) {
			child[p][c] = ++tot;
		}
		p = child[p][c];
	}
}

void get(int value) {
	// 尽量每位反着选
	int p = 1;
	int res = 0;
	for (int i = 30; i >= 0; i--) {
		int c = (value >> i) & 1;
		if (child[p][c ^ 1]) {
			p = child[p][c ^ 1]; //当前位为 1 
			res |= (1 << i);//记录
		} else {
			p = child[p][c];
		}
	}
	ans = max(ans, res);
}

void dfs(int root, int fa) {
	insert(dis[root]);
	get(dis[root]);
	for (int i = head[root]; i; i = nxt[i]) {
		int v = to[i];
		if (v == fa) continue;
		dis[v] = dis[root] ^ weight[i];
		dfs(v, root);
	}
}

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n - 1; i++) {
		int u, v, w;
		cin >> u >> v >> w;

		add(u, v, w);
		add(v, u, w);
	}

	//任选一个作根节点
	dfs(1, 0);

	cout << ans << endl;
	return 0;
}
```

### 维护异或和

$01-trie$是指所有字符集为${0,1}$的$trie$。$01-trie$可以用来维护一些数字的异或和，支持修改（删除+重新插入），和全局加一（即：让其所维护的所有数值递增$1$，本质上是一种特殊的修改操作）。

如果要维护异或和，需要按值从低位到高位建立$trie$。

文中说当前节点**往上**指当前节点到根这条路径，当前节点**往下**指当前节点的子树。

#### 插入 & 删除

如果要维护异或和，我们只需要知道某一位上$0$和$1$个数的**奇偶性**即可，也就是对数字$1$来说，当且仅当这一位上数字$1$的个数为奇数时，这一位上的数字才是$1$，







































































