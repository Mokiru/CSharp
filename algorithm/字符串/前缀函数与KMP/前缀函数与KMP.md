# 前缀函数与KMP算法

## 前缀函数

### 定义

给定一个长度为$n$的字符串$s$，其**前缀函数**被定义为一个长度为$n$的数组$\pi$。其中$\pi[i]$的定义是：
1. 如果子串$s[0...i]$有一对相等的真前缀与真后缀：$s[0...k-1]$和$s[i-(k-1)...i]$那么$\pi[i]$就是这个相等的真前缀（或者真后缀，因为它们相等）的长度，也就是$\pi[i]=k$；
2. 如果不止有一对相等，那么$\pi[i]$就是其中最长的那一对的长度；
3. 如果没有相等，那么$\pi[i]=0$。

简单来说$\pi[i]$就是，子串$s[0...i]$最长的相等真前缀和真后缀的长度。

$$
\pi[i] = \underset{\max}{k=0...i} \{
    k:s[0...k-1]
    =
    s[i-(k-1)...i]
    \}
$$

特别地，规定$\pi[0]=0$。

### 过程

举例来说，对于字符串`abcabcd`。

$\pi[0]=0$，因为`a`没有真前缀和真后缀，根据规定为$0$

$\pi[1]=0$，因为`ab`无相等的真前缀和真后缀

$\pi[2]=0$，因为`abc`无相等的真前缀和真后缀

$\pi[3]=1$，因为`abca`只有一对相等打的真前缀和真后缀：`a`，长度为$1$

$\pi[4]=2$，因为`abcab`相等的真前缀和真后缀只有`ab`，长度为$2$

$\pi[5]=3$，因为`abcabc`相等的真前缀和真后缀只有`abc`，长度为$3$

$\pi[6]=0$，因为`abcabcd`无相等的真前缀和真后缀

同理可以计算字符串`aabaaab`的前缀函数为$[0,1,0,1,2,2,3]$。

## 计算前缀函数的朴素算法

### 过程

一个直接按照定义计算前缀函数的算法流程：
- 在一个循环中以$i=1\rightarrow n-1$的顺序计算前缀函数$\pi[i]$的值（$\pi[0]$被赋值为$0$）。
- 为了计算当前的前缀函数值$\pi[i]$，我们令变量$j$从最大的真前缀长度$i$开始尝试。
- 如果当前长度下真前缀和真后缀相等，则此时长度为$\pi[i]$，否则令$j$自减$1$，继续匹配，直到$j=0$。
- 如果$j=0$并且仍没有任何一次匹配，重置$\pi[i]=0$并移至下一个下标$i+1$。

```c++
vector<int> prefix_function(string s) {
    int n = s.size();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        for (int j = i; j >= 0; j--) {
            if (s.substr(0, j) == s.substr(i - j - 1, j)) {
                pi[i] = j;
                break;
            }
        }
    }
    return pi;
}
```
该算法的时间复杂度为$O(n^3)$。

## 计算前缀函数的高效算法

### 第一个优化

第一个重要的观察是**相邻的前缀函数值至多增加$1$**。

如下式子，只需要考虑：当取一个尽可能大的$\pi[i+1]$时，必然要求新增的$s[i+1]$也与之对应的字符匹配，即$s[i+1]=s[\pi[i]]$，此时$\pi[i+1]=\pi[i]+1$。

$$
\underbrace{\overbrace{s_0,s_1,s_2,s_3}^{\pi[i]=3},s_4}_{\pi[i+1]=4}···\underbrace{\overbrace{s_{i-2},s_{i-1},s_{i}}^{\pi[i]=3},s_{i+1}}_{\pi[i+1]=4}
$$

所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。

```c++
vector<int> prefix_function(string s) {
    int n = s.size();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        for (int j = pi[i - 1] + 1; j >= 0; j--) {
            if (s.substr(0, j) == s.substr(i - j + 1, j)) {
                pi[i] = j;
                break;
            }
        }
    }
    return pi;
}
```

在这个初步改进的算法中，在计算每个$\pi[i]$时，最好的情况是第一次字符串比较就完成了匹配，也就是说基础的字符串比较次数是$n-1$次。

而由于存在$j=\pi[i-1]+1$（$\pi[0]=0$）对于最大字符串比较次数的限制，可以看出每次只有在最好情况才会为字符串比较次数的上限累积$1$，而每次超过一次的字符串比较消耗的是之后次数的增长空间。

由此我们可以得出字符串比较次数最多的一种情况：至少$1$次字符串比较次数的消耗和最多$n-2$次比较次数的积累，此时字符串比较次数为$n-1+n-2=2n-3$。

可见经过此次优化，计算前缀函数只需要进行$O(n)$次字符串比较，总复杂度降为了$O(n^2)$。

### 第二个优化

在第一个优化中，我们讨论计算了$\pi[i+1]$时最好情况：$s[i+1]=s[\pi[i]]$，此时$\pi[i+1]=\pi[i]+1$，现在让我们沿着这个思路：讨论$s[i+1]\neq s[\pi[i]]$时如何跳转。

失配时，我们希望找到对于子串$s[0...i]$，仅次于$\pi[i]$的第二长度$j$，使得在位置$i$的前缀性质仍得以保持，也即$s[0...j-1]=s[i-j+1...i]$：

$$
\overbrace{\underbrace{s_0,s_1}_{j},s_2,s_3}^{\pi[i]}...\overbrace{s_{i-3},s_{i-2},\underbrace{s_{i-1},s_{i}}_{j}}^{\pi[i]},s_{i+1}
$$

如果我们找到了这样的长度$j$，那么仅需要再次比较$s[i+1]$和$s[j]$。如果它们相等，那么就有$\pi[i+1]= j+1$。否则，我们需要找到子串$s[0...i]$仅次于$j$的第二长度$j^{(2)}$，使得前缀性质得以保持，如此反复，直到$j=0$。如果$s[i+1]\neq s[0]$，则$\pi[i+1]=0$。

观察上述式子可以发现，因为$s[0...\pi[i]-1]=s[i-\pi[i]+1...i]$，所以对于$s[0...i]$的第二长度$j$，有这样的性质：

$$
s[0...j-1]=s[i-j+1...i]=s[\pi[i]-j...\pi[i]-1]
$$

也就是说$j$等价于子串$s[\pi[i]-1]$的前缀函数值，即$j=\pi[\pi[i]-1]$。同理，次于$j$的第二长度等价于$s[j-1]$的前缀函数值，$j^{(2)}=\pi[j-1]$

显然我们可以得到一个关于$j$的状态转移方程：$j^{(n)}=\pi[j^{(n-1)}-1],(j^{(n-1)}>0$

### 最终

所以最终我们可以构建一个不需要任何字符串比较，并且只进行$O(n)$次操作的算法。

```c++
vector<int> prefix_function(string s) {
    int n = s.size();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }
        if (s[i] == s[j]) j++;
        pi[i] = j;
    }
    return pi;
}
```

这是一个**在线**算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们预先知道该字符串前缀函数的最大可能取值$M$，那我们仅需要存储该字符串的前$M+1$个字符以及对应的前缀函数值。

## 应用

### 在字符串中查找子串：Knuth-Morris-Pratt算法

该算法由Knuth、Pratt和Morris在1977年共同发布。

#### 过程

给定一个文本$t$和一个字符串$s$，我们尝试找到并展示$s$在$t$中的所有出现（occurrence）。

为了简便起见，我们用$n$表示字符串$s$的长度。

我们构造一个字符串$s+x+t$，其中$x$为一个既不出现在$s$也不出现在$t$中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始$n+1$个值（即属于字符串$s$和分隔符的函数值）后其余函数值的意义。根据定义，$\pi[i]$为右端点在$i$且同时为一个前缀的最长真子串的长度，具体到我们的这种情况下，其值为与$s$的前缀相同且右端点位于$i$的最长子串的长度。由于分隔符的存在，该长度不可能超过$n$。而如果等式$\pi[i]=n$成立，则意味着$s$完整出现在该位置（即其右端点位于位置$i$）。注意该位置的下标是对字符串$s+x+t$而言的。

因此如果在某一位置$i$有$\pi[i]=n$成立，则字符串$s$在字符串$t$的$i-(n-1)-(n+1)=i-2n$处出现。

正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串$s+x$以及相应的前缀函数值即可。我们可以一次读入字符串$t$的一个字符并计算当前位置的前缀函数值。

因此KMP算法用$O(n+m)$的时间及$O(n)$的内存解决了该问题。

```c++
vector<int> find_occurrences(string text, string pattern) {
    string cur = pattern + '#' + text;
    int sz1 = text.size();
    int sz2 = pattern.size();
    vector<int> v;
    vector<int> lps = prefix_function(cur);
    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {
        if (lps[i] == sz2) v.push_back(i - 2 * sz2);
    }
    return v;
}
```

### 根据前缀函数构建一个自动机

让我们重新回到通过一个分隔符将两个字符串拼接的新字符串。对于字符串$s$和$t$我们计算$s+x+t$的前缀函数。显然，因为$x$是一个分隔符，前缀函数值永远不会超过$|s|$。因此我们只需要存储字符串$s+x$和其对应的前缀函数值，之后就可以动态计算对于之后所有字符的前缀函数值：

$$
\underbrace{s_0,s_1,....,s_{n-1},x,}_{need to store}\underbrace{t_0,t_1,...,t_{m-1}}_{do not need to store}
$$

实际上在这种情况下，知道$t$的下一个字符$c$以及之前位置的前缀函数值便足以计算下一个位置的前缀函数值，而不需要用到任何其它$t$的字符和对应的前缀函数值。

换句话说，我们可以构造一个**自动机**（一个有限状态机）：其状态为当前的前缀函数值，而从一个状态到另一个状态的转移则由下一个字符确定。

因此，即便没有字符串$t$，我们同样可以应用构造转移表的算法构造一个转移表$(old\pi,c)\rightarrow new_\pi:$

```c++
void compute_automaton(string s, vector<vector<int>>& aut) {
    s += '#';
    int n = s.size();
    vector<int> pi = prefix_function(s);
    aut.assign(n, vector<int>(26));
    for (int i = 0; i < n; i++) {
        for (int c = 0; c < 26; c++) {
            int j = i;
            while (j > 0 && 'a' + c != s[j]) j = pi[j - 1];
            if ('a' + c == s[j]) j++;
            aut[i][c] = j;
        }
    }
}
```

然而在这种形式下，对于小写字母表，算法的时间复杂度为$O(|\sum|n^2)$。注意到我们可以应用动态规划来利用表中已经计算过的部分。只要我们从值$j$变化到$\pi[j-1]$，那么我们实际上在说转移$(j,c)$所到达的状态同转移$(\pi[j-1],c)$一样，但该答案我们之前已经精确计算过了。

```c++
void compute_automaton(string s, vector<vector<int>>& aut) {
    s += '#';
    int n = s.size();
    vector<int> pi = prefix_function(s);
    aut.assign(n, vector<int>(26));
    for (int i = 0; i < n; i++) {
        for (int c = 0; c < 26; c++) {
            if (i > 0 && 'a' + c != s[i]) {
                aut[i][c] = aut[pi[i-1]][c];
            } else {
                aut[i][c] = i + ('a' + c == s[i]);
            }
        }
    }
}
```

最终我们可以在$O(|\sum|n)$的时间复杂度内构造该自动机。

该自动机在什么时候有用呢？首先，记得大部分时候我们为了一个目的使用字符串$s+x+t$的前缀函数：寻找字符串$s$在字符串$t$中的所有出现。

因此使用该自动机的最直接的好处是**加速计算字符串$s+x+t$的前缀函数**。

通过构建$s+x$的自动机，我们不再需要存储字符串$s$以及其对应的前缀函数值。所有转移已经在表中计算过了。

但除此之外，还有第二个不那么直接的应用，我们可以在字符串$t$是**某些通过一些规则构造的巨型字符串**时，使用该自动机加速计算。$Gray$字符串，或者一个由一些短的输入串的递归组合所构造的字符串都是这种例子。

出于完整性考虑，我们来解决这样一个问题：给定一个数$k\leq 10^5$，以及一个长度$\leq 10^5$的字符串$s$，我们需要计算$s$在第$k$个$Gray$字符串中的出现次数。$Gray$字符串以下述方式定义：

$$
g_1=a\
g_2=aba\
g_3=abacaba\
g_4=abacabadabacaba\
$$

由于其天文数字般的长度，在这种情况下即使构造字符串$t$都是不可能的：第$k$个$Gray$字符串有$2^k-1$个字符。然而我们可以在仅仅知道开头若干前缀函数值的情况下，有效计算该字符串末尾的前缀函数值。

除了自动机之外，我们同时需要计算值$G[i][j]$：在状态$j$开始处理$g_i$后的自动机的状态，以及值$K[i][j]$：当从状态$j$开始处理$g_i$后，$s$在$g_i$中的出现次数。实际上$K[i][j]$为在执行操作时前缀函数取值为$|s|$的次数。易得问题的答案为$K[k][0]$。

我们该如何计算这些值呢？首先根据定义，


