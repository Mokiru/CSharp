# 代理模式

## 动态代理

相比于静态代理来说，动态代理更加灵活，我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类（CGLIB）。

从 $JVM$ 角度来说，动态代理是在运行时动态生成类字节码，并加载到 $JVM$ 中的。

说到动态代理， **Spring AOP, RPC** 框架应该是两个不得不提的，它们的实现都依赖了动态代理。

动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。

就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB动态代理等等。

## JDK动态代理

在 Java动态代理机制中，`InvocationHandler` 接口和 `Proxy` 类是核心。

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()`，这个方法主要用来生成一个代理对象。

```java
public static object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h) 
throws IllegalArgumentException
{
    Objects.requireNonNull(h);

    @SuppressWarnings("removal")
    final Class<?> caller = System.getSecurityManager() == null
                                ? null
                                : Reflection.getCallerClass();

    /*
    * Look up or generate the designated proxy class and its constructor.
    */
    Constructor<?> cons = getProxyConstructor(caller, loader, interfaces);

    return newProxyInstance(caller, cons, h);
}
```

这个方法一共有 $3$ 个参数：
1. `loader` ：类加载器，用于加载代理对象。
2. `interfaces` ：被代理类实现的一些接口
3. `h` ：实现了`invocationHandler` 接口的对象。

要实现这个代理的话，还必须需要实现 `InvocationHandler` 来自定义处理逻辑。当我们动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 `InvocationHandler` 接口类的 `invoke` 方法来调用。

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}

```

`invoke()` 方法有下面三个参数：
1. `proxy` ：动态生成的代理类。
2. `method`：与代理类对象调用的方法相对应。
3. `args`：当前`method`方法的参数。

也就是说，你通过 `Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现 `InvocationHandler`接口的类的`invoke()` 方法。你可以在`invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

### JDK动态代理类使用步骤

1. 定义一个接口以及其实现类。
2. 自定义 `InvocationHandler` 并重写 `invoke` 方法，在`invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑。
3. 通过 `Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象。

### 示例

1. 自定义一个接口

```java
interface Serv {
   void send(String message);
}
```

2. 实现该接口

```java
class ServImpl implements Serv {
    @Override
    public void send(String message) {
        System.out.println(message);
    }
}
```

3. 定义一个JDK动态代理类

```java
class ServInvocationHandler implements InvocationHandler {
    private final Object target;

    ServInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException {
        System.out.println("Before");
        Object res = method.invoke(target, args);
        System.out.println("after");
        return res;
    }
}
```

4. 获取代理对象的工厂类

```java
class ServProxy {
    public Object getProxy(Object target) {
        return Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new ServInvocationHandler(target)
        );
    }
}
```

`getProxy()` ：主要通过`Proxy.newProxyInstance()` 方法获取某个类的代理对象。

5. 实际使用

```java
Serv s = (Serv) ServProxy.getProxy(new ServImpl());
s.send("java"); 
```

```java
Before
java
after
```