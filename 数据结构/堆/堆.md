# 二叉堆

## 结构

从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个节点中存有一个元素（或者说，有个权值）。

堆性质：父亲的权值不小于儿子的权值（大根堆），同样，我们可以定义小根堆，本文以大根堆为例。

由堆性质，树根存的是最大值（getmax操作就解决了）

## 过程

### 插入操作

插入操作是指向二叉堆中插入一个元素，要保证插入过后也是一棵完全二叉树。

最简单的方法就是，最下一层最右边的叶子节点之后插入。如果最下一层满了就新增一层。

插入之后可能不满足堆的性质。

**向上调整**：如果这个节点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根处。

可以证明，插入之后向上调整后，没有其他结点会不满足堆性质。

向上调整的时间复杂度是O(logn)。

![alt text](https://oi-wiki.org/ds/images/binary_heap_insert.svg)

### 删除操作

删除操作这里只指删除堆的根结点，即最大值or最小值。

但是如果直接删除，则变成了两个堆，难以处理。

所以不妨考虑插入操作的逆过程，设法将根结点移动到最后一个结点，然后删除掉。

然而实际实现并不好做，我们通常采用将根节点与最后一个节点交换，然后删除。显然这样交换过后，新的根结点可能不满足堆性质。

**向下调整**：在该结点的儿子中，找到一个最大的，与该节点交换，重复此过程直到底层。可以证明，删除并向下调整过后，没有结点不满足堆性质。

时间复杂度为O(logn)。

### 增加某个点的权值

显然，修改过后，对于大根堆，向上调整一次即可，时间复杂度O(logn)

## 实现

我们发现，上面介绍的几种操作主要依赖于两个核心：向上调整和向下调整。

考虑使用一个序列$h$来表示堆，$h_i$的两个儿子分别是$h_{2i}$和$h_{2i+1}$，1是根节点。

![alt text](image-1.png)

```c++
void up(int x)
{
    while (x > 1 && h[x] > h[x / 2]) // 当前不是根结点且大于父结点
    {
        swap(h[x], h[x / 2]);
        x /= 2;
    }
}
void down(int x)
{
    while (x * 2 <= n)
    {
        t = x * 2;
        if (t + 1 <= n && h[t + 1] > h[t]) t++; // 看左右子结点谁更大
        if (h[t] <= h[x]) break; // 比较子结点和当前结点
        swap(h[x], h[t]);
        x = t;
    }
}
```

## 建堆

考虑这么一个问题，从一个空的堆开始，插入n个元素，不在乎顺序。直接一个一个插入需要O(nlogn)的时间，那么有更好的方法吗？

### 使用向上调整

从根开始，按BFS序进行。
```c++
void build_heap_1() {
    for (int i = 1; i <= n; i++) up(i);
}
```

为什么这么做呢：对于第$k$层的结点，向上调整的时间复杂度是O(k)而不是O(logn)。

总的时间复杂度是$log1 + log2 + .... logn = O(nlogn)$。

### 使用向下调整

这时换一种思路，从叶子开始，逐个向下调整。

```c++
void build_heap_2() {
    for (int i = n; i >= 1; i--) down(i);
}
```

换一种理解方法，每次合并两个已经调整好的堆。

注意向下调整的时间复杂度是O(logn - k)，另外叶子结点无需调整，因此可从序列约n/2的位置开始调整，但不影响整体复杂度。

$nlogn - log1 - log2 - .... - logn = O(n)$

之所以能用O(n)时间复杂度建堆，是因为堆性质很弱，二叉堆并不是唯一的。