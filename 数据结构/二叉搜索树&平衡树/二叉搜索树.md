# 二叉搜索树&平衡树

## 定义

二叉搜索树是一种二叉树的树形数据结构，其定义如下：
1. 空树是二叉搜索树。
2. 若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。
3. 若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。
4. 二叉搜索树的左右子树均为二叉搜索树。

二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比，对于一个有$n$个结点的二叉搜索树种，这些操作的最优时间复杂度为$O(logn)$，最坏为$O(n)$，随机构造这样一棵二叉搜索树的期望高度为$O(logn)$。

## 过程

### 二叉搜索树节点的定义

```c++
struct TreeNode {
    int key;
    TreeNode* left;
    TreeNode* right;
    //维护其他信息，如高度，节点数量等
    int size; // 当前节点为根的子树大小
    int count; //当前节点的重复数量

    TreeNode(int value) : key(value), size(1), count(1), left(nullptr), right(nullptr) {}
};
```

### 遍历二叉搜索树

由二叉搜索树的递归定义可得，二叉搜索树的中序遍历权值的序列为非降的序列，时间复杂度为$O(n)$。

```c++
void inorderTraversal(TreeNode* root) {
    if (root = nullptr) {
        return;
    }
    inorderTraversal(root->left);
    cout << root-> key;
    inorderTraversal(root->right);
}
```

### 查找最小/最大值

由二叉搜索树的性质可得，二叉搜索树上的最小值为二叉搜索树左链的顶点，最大值为二叉搜索树右链的顶点，时间复杂度为$O(h)$。

```c++
int findMin(TreeNode* root) {
    if (root == nullptr) {
        return -1;
    }
    while (root->left != nullptr) {
        root = root->left;
    }
    return root->key;
}

TreeNode* findMinNode(TreeNode* root) {
    while (root->left != nullptr) {
        root = root->left;
    }
    return root;
}

int findMax(TreeNode* root) {
    if (root == nullptr) {
        return -1;
    }
    while (root->right != nullptr) {
        root = root->right;
    }
    return root->key;
}

TreeNode* findMaxNode(TreeNode* root) {
    while (root->right != nullptr) {
        root = root->right;
    }
    return root;
}

```

### 搜索元素

在以`root`为根节点的二叉搜索树中搜索一个值为`value`的节点。

分类讨论如下：
- 若`root`为空，返回`false`
- 若`root`的权值等于`value`，返回`true`
- 若`root`的权值大于`value`，在`root`的左子树中继续搜索
- 若`root`的权值小于`value`，在`root`的右子树中继续搜索

时间复杂度为$O(h)$。
```c++
bool search(TreeNode* root, int target) {
    if (root == nullptr) {
        return false;
    }
    if (root->key == target) {
        return true;
    } else if (target < root->key) {
        return search(root->left, target);
    } else {
        return search(root->right, target);
    }
}
```
插入，删除，修改都需要现在二叉搜索树中进行搜索

### 插入一个元素

在以`root`为根节点的二叉搜索树中插入一个值为`value`的节点。

分类讨论如下：
- 若`root`为空，直接返回一个值为`value`的新节点
- 若`root`的权值等于`value`，该节点的附加域该值的出现次数自增1
- 若`root`的权值大于`value`，在`root`的左子树中插入权值为`value`的节点
- 若`root`的权值小于`value`，在`root`的右子树中插入权值为`value`的节点

时间复杂度为$O(h)$。
```c++
TreeNode* insert(TreeNode* root, int value) {
    if (root == nullptr) {
        return new TreeNode(value);
    }
    if (value < root->key) {
        root->left = insert(root->left, value);
    } else if (value > root->key) {
        root->right = insert(root->right, value);
    } else {
        root->count++;
    }
    root->size = root->count + (root->left ? root->left->size : 0) + (root->right ? root->right->size : 0);
    return root;
}
```

### 删除一个元素

在以`root`为根节点的二叉搜索树中删除一个值为`value`的节点。

先在二叉搜索树中搜索权值为`value`的节点，分类讨论如下：
- 若该节点的附加`count`大于1，则只需要减少`count`
- 若该节点的附加权值`count`为1：
    - 若`root`为叶子节点，直接删除即可
    - 若`root`为链节点，即只有一个儿子的节点，返回这个儿子
    - 若`root`有两个非空子节点，一般用它左子树的最大值（左子树最右的节点）或右子树的最小值（右子树最左的节点）代替它，然后删除

时间复杂度为$O(h)$

```c++
TreeNode* remove(TreeNode* root, int value) {
    if (root == nullptr) {
        return root;
    }
    if (value < root->key) {
        root->left = remove(root->left, value);
    } else if (value > root->key) {
        root->right = remove(root->right, value);
    } else {
        if (root->count > 1) {
            root->count--;
        } else {
            if (root->left == nullptr) {
                TreeNode* temp = root->right;
                delete root;
                return temp;
            } else if (root->right == nullptr) {
                TreeNode* temp = root->left;
                delete root;
                return temp;
            } else {
                TreeNode* successor = findMinNode(root->right);
                root->key = successor->key;
                root->count = successor->count;
                root->right = remove(root->right, successor->key);
            }
        }
    }
    return root;
}
```


